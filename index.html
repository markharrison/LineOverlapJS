<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>PlankJS Line Overlap Detection Demo</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #1a1a1a;
                color: #ffffff;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
            }

            h1 {
                text-align: center;
                color: #00ff80;
                margin-bottom: 30px;
            }

            .demo-section {
                background-color: #2a2a2a;
                border-radius: 10px;
                padding: 20px;
                margin-bottom: 20px;
                border: 1px solid #444;
            }

            .demo-title {
                color: #ff8000;
                font-size: 18px;
                font-weight: bold;
                margin-bottom: 15px;
            }

            .canvas-container {
                position: relative;
                margin: 20px 0;
                border: 2px solid #444;
                border-radius: 5px;
            }

            canvas {
                display: block;
                background-color: #111;
                border-radius: 3px;
            }

            .controls {
                display: flex;
                gap: 10px;
                margin: 10px 0;
                flex-wrap: wrap;
            }

            button {
                background-color: #0080ff;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
            }

            button:hover {
                background-color: #0060cc;
            }

            button:disabled {
                background-color: #666;
                cursor: not-allowed;
            }

            .info-panel {
                background-color: #333;
                padding: 15px;
                border-radius: 5px;
                margin: 10px 0;
                font-family: monospace;
                font-size: 12px;
                line-height: 1.4;
                max-height: 200px;
                overflow-y: auto;
            }

            .status {
                color: #00ff80;
                font-weight: bold;
            }

            .warning {
                color: #ff8000;
            }

            .error {
                color: #ff0080;
            }

            .description {
                color: #ccc;
                margin-bottom: 15px;
                line-height: 1.5;
            }

            .legend {
                display: flex;
                gap: 20px;
                margin: 10px 0;
                flex-wrap: wrap;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 5px;
                font-size: 12px;
            }

            .legend-color {
                width: 20px;
                height: 3px;
                border-radius: 2px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>PlankJS Line Overlap Detection Demo</h1>

            <!-- Demo 1: Basic Line-Body Intersection -->
            <div class="demo-section">
                <div class="demo-title">Demo 1: Basic Line-Body Intersection</div>
                <div class="description">
                    Move your mouse to create a line from the center. The line will change color when it intersects with bodies.
                    Bodies are automatically created and move around the canvas.
                </div>
                <div class="canvas-container">
                    <canvas id="demo1Canvas" width="800" height="400"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff0000"></div>
                        <span>Line (no intersection)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00ff00"></div>
                        <span>Line (intersecting)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffff00"></div>
                        <span>Intersection points</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00ffff"></div>
                        <span>Surface normals</span>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="demo1.addRandomBody()">Add Random Body</button>
                    <button onclick="demo1.clearBodies()">Clear All Bodies</button>
                    <button onclick="demo1.resetBodies()">Reset Demo</button>
                </div>
                <div id="demo1Info" class="info-panel">Move mouse over canvas to see line intersection detection...</div>
            </div>

            <!-- Demo 2: Ray Casting in Multiple Directions -->
            <div class="demo-section">
                <div class="demo-title">Demo 2: 360Â° Ray Casting Scanner</div>
                <div class="description">
                    Click anywhere to position a scanning radar that casts rays in all directions. Rays turn green when they hit
                    bodies, showing distance and surface normals.
                </div>
                <div class="canvas-container">
                    <canvas id="demo2Canvas" width="800" height="400"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #666"></div>
                        <span>Scan rays (no hit)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00ff00"></div>
                        <span>Scan rays (hit)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff8000"></div>
                        <span>Scanner center</span>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="demo2.addRandomBody()">Add Random Body</button>
                    <button onclick="demo2.clearBodies()">Clear All Bodies</button>
                    <button onclick="demo2.resetDemo()">Reset Demo</button>
                    <button onclick="demo2.toggleAnimation()">Toggle Animation</button>
                </div>
                <div id="demo2Info" class="info-panel">Click anywhere on canvas to position scanner...</div>
            </div>

            <!-- Demo 3: Line of Sight Testing -->
            <div class="demo-section">
                <div class="demo-title">Demo 3: Line of Sight & Path Finding</div>
                <div class="description">
                    Click two points to test line of sight between them. The line shows green if there's a clear path, red if
                    blocked by obstacles. Shows practical use for AI pathfinding and visibility systems.
                </div>
                <div class="canvas-container">
                    <canvas id="demo3Canvas" width="800" height="400"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00ff00"></div>
                        <span>Clear line of sight</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff0000"></div>
                        <span>Blocked line of sight</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #8000ff"></div>
                        <span>Start/End points</span>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="demo3.addObstacle()">Add Obstacle</button>
                    <button onclick="demo3.clearObstacles()">Clear Obstacles</button>
                    <button onclick="demo3.resetDemo()">Reset Demo</button>
                    <button onclick="demo3.runPathTest()">Auto Path Test</button>
                </div>
                <div id="demo3Info" class="info-panel">Click two points to test line of sight...</div>
            </div>

            <!-- Demo 4: Laser/Projectile Simulation -->
            <div class="demo-section">
                <div class="demo-title">Demo 4: Laser/Projectile Targeting System</div>
                <div class="description">
                    Click and drag to aim a laser. The system shows which targets would be hit and in what order. Perfect for games
                    with shooting mechanics or targeting systems.
                </div>
                <div class="canvas-container">
                    <canvas id="demo4Canvas" width="800" height="400"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff0000"></div>
                        <span>Laser beam</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffff00"></div>
                        <span>Impact points</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff8000"></div>
                        <span>Targets</span>
                    </div>
                </div>
                <div class="controls">
                    <button onclick="demo4.addTarget()">Add Target</button>
                    <button onclick="demo4.clearTargets()">Clear Targets</button>
                    <button onclick="demo4.resetDemo()">Reset Demo</button>
                    <button onclick="demo4.fireLaser()">Fire Laser!</button>
                </div>
                <div id="demo4Info" class="info-panel">Click and drag to aim laser...</div>
            </div>
        </div>

        <!-- Include PlankJS -->
        <script src="lib/planck.min.js"></script>

        <!-- Demo Implementation -->
        <script type="module">
            // Simple LineOverlapDetector implementation for demo
            class SimpleLineOverlapDetector {
                constructor(world) {
                    this.world = world;
                }

                checkLineOverlap(lineStart, lineEnd, bodyFilter = null) {
                    if (!this.world) return [];
                    if (!lineStart || !lineEnd || typeof lineStart.x === 'undefined' || typeof lineEnd.x === 'undefined') {
                        return [];
                    }

                    const SCALE = 30; // pixels per meter
                    const point1 = {
                        x: lineStart.x / SCALE,
                        y: lineStart.y / SCALE,
                    };
                    const point2 = {
                        x: lineEnd.x / SCALE,
                        y: lineEnd.y / SCALE,
                    };

                    const overlaps = [];

                    this.world.rayCast(point1, point2, (fixture, point, normal, fraction) => {
                        const body = fixture.getBody();

                        if (bodyFilter && !bodyFilter(body)) {
                            return 1.0;
                        }

                        overlaps.push({
                            body: body,
                            fixture: fixture,
                            point: { x: point.x * SCALE, y: point.y * SCALE },
                            normal: { x: normal.x, y: normal.y },
                            fraction: fraction,
                            userData: body.getUserData(),
                        });

                        return 1.0;
                    });

                    return overlaps;
                }

                hasLineOverlap(lineStart, lineEnd, bodyFilter = null) {
                    const overlaps = this.checkLineOverlap(lineStart, lineEnd, bodyFilter);
                    return overlaps.length > 0;
                }

                getClosestLineOverlap(lineStart, lineEnd, bodyFilter = null) {
                    if (!this.world) return null;
                    if (!lineStart || !lineEnd || typeof lineStart.x === 'undefined' || typeof lineEnd.x === 'undefined') {
                        return null;
                    }

                    const SCALE = 30;
                    const point1 = {
                        x: lineStart.x / SCALE,
                        y: lineStart.y / SCALE,
                    };
                    const point2 = {
                        x: lineEnd.x / SCALE,
                        y: lineEnd.y / SCALE,
                    };

                    let closest = null;

                    this.world.rayCast(point1, point2, (fixture, point, normal, fraction) => {
                        const body = fixture.getBody();

                        if (bodyFilter && !bodyFilter(body)) {
                            return 1.0;
                        }

                        closest = {
                            body: body,
                            fixture: fixture,
                            point: { x: point.x * SCALE, y: point.y * SCALE },
                            normal: { x: normal.x, y: normal.y },
                            fraction: fraction,
                            userData: body.getUserData(),
                        };

                        return fraction;
                    });

                    return closest;
                }
            }

            // Demo Base Class
            class DemoBase {
                constructor(canvasId, infoId) {
                    this.canvas = document.getElementById(canvasId);
                    this.ctx = this.canvas.getContext('2d');
                    this.infoElement = document.getElementById(infoId);
                    this.SCALE = 30; // pixels per meter

                    this.world = new planck.World({ gravity: { x: 0, y: 0 } });
                    this.detector = new SimpleLineOverlapDetector(this.world);
                    this.bodies = [];
                    this.initialized = false;

                    this.setupEvents();
                    this.init();
                    this.initialized = true;
                    this.animate();
                }

                setupEvents() {
                    // Override in subclasses
                }

                init() {
                    // Override in subclasses
                }

                createBody(x, y, width, height, type = 'dynamic', userData = {}) {
                    const body = this.world.createBody({
                        type: type,
                        position: { x: x / this.SCALE, y: y / this.SCALE },
                    });

                    body.createFixture({
                        shape: new planck.Box(width / (2 * this.SCALE), height / (2 * this.SCALE)),
                        density: 1.0,
                        friction: 0.3,
                    });

                    body.setUserData(userData);
                    this.bodies.push(body);
                    return body;
                }

                createCircle(x, y, radius, type = 'dynamic', userData = {}) {
                    const body = this.world.createBody({
                        type: type,
                        position: { x: x / this.SCALE, y: y / this.SCALE },
                    });

                    body.createFixture({
                        shape: new planck.Circle(radius / this.SCALE),
                        density: 1.0,
                        friction: 0.3,
                    });

                    body.setUserData(userData);
                    this.bodies.push(body);
                    return body;
                }

                drawBody(body) {
                    const pos = body.getPosition();
                    const angle = body.getAngle();
                    const x = pos.x * this.SCALE;
                    const y = pos.y * this.SCALE;

                    this.ctx.save();
                    this.ctx.translate(x, y);
                    this.ctx.rotate(angle);

                    for (let fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {
                        const shape = fixture.getShape();
                        const userData = body.getUserData();
                        const color = userData.color || '#0080ff';

                        this.ctx.fillStyle = color;
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;

                        if (shape.getType() === planck.Circle.TYPE) {
                            const radius = shape.getRadius() * this.SCALE;
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.stroke();
                        } else if (shape.getType() === planck.Polygon.TYPE) {
                            const vertices = shape.m_vertices;
                            this.ctx.beginPath();
                            this.ctx.moveTo(vertices[0].x * this.SCALE, vertices[0].y * this.SCALE);
                            for (let i = 1; i < vertices.length; i++) {
                                this.ctx.lineTo(vertices[i].x * this.SCALE, vertices[i].y * this.SCALE);
                            }
                            this.ctx.closePath();
                            this.ctx.fill();
                            this.ctx.stroke();
                        }
                    }

                    this.ctx.restore();
                }

                drawLine(start, end, color = '#ff0000', width = 2) {
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = width;
                    this.ctx.beginPath();
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(end.x, end.y);
                    this.ctx.stroke();
                }

                drawPoint(x, y, color = '#ffff00', radius = 4) {
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                updateInfo(text) {
                    this.infoElement.innerHTML = text;
                }

                clearBodies() {
                    this.bodies.forEach((body) => this.world.destroyBody(body));
                    this.bodies = [];
                }

                animate() {
                    if (this.initialized) {
                        this.world.step(1 / 60);
                        this.render();
                    }
                    requestAnimationFrame(() => this.animate());
                }

                render() {
                    if (!this.initialized) return;
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.bodies.forEach((body) => this.drawBody(body));
                }
            }

            // Demo 1: Basic Line-Body Intersection
            class Demo1 extends DemoBase {
                constructor() {
                    super('demo1Canvas', 'demo1Info');
                }

                setupEvents() {
                    this.canvas.addEventListener('mousemove', (e) => {
                        const rect = this.canvas.getBoundingClientRect();
                        this.mousePos = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top,
                        };
                    });
                }

                init() {
                    // Initialize positions first
                    this.mousePos = { x: 400, y: 200 };
                    this.centerPos = { x: 400, y: 200 };
                    this.resetBodies();
                }

                resetBodies() {
                    this.clearBodies();
                    // Add some random bodies
                    for (let i = 0; i < 8; i++) {
                        this.addRandomBody();
                    }
                }

                addRandomBody() {
                    const x = Math.random() * (this.canvas.width - 100) + 50;
                    const y = Math.random() * (this.canvas.height - 100) + 50;
                    const size = Math.random() * 30 + 20;

                    if (Math.random() > 0.5) {
                        this.createCircle(x, y, size, 'dynamic', {
                            color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                            type: 'target',
                        });
                    } else {
                        this.createBody(x, y, size, size, 'dynamic', {
                            color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                            type: 'target',
                        });
                    }
                }

                render() {
                    super.render();

                    // Draw line from center to mouse
                    const overlaps = this.detector.checkLineOverlap(this.centerPos, this.mousePos);
                    const hasOverlap = overlaps.length > 0;

                    this.drawLine(this.centerPos, this.mousePos, hasOverlap ? '#00ff00' : '#ff0000', 3);
                    this.drawPoint(this.centerPos.x, this.centerPos.y, '#ffffff', 6);

                    // Draw intersection points and normals
                    overlaps.forEach((overlap) => {
                        this.drawPoint(overlap.point.x, overlap.point.y, '#ffff00', 6);

                        // Draw normal vector
                        const normalEnd = {
                            x: overlap.point.x + overlap.normal.x * 30,
                            y: overlap.point.y + overlap.normal.y * 30,
                        };
                        this.drawLine(overlap.point, normalEnd, '#00ffff', 2);
                    });

                    // Update info
                    let info = `<div class="status">Line Intersection Detection</div>`;
                    info += `Intersections: ${overlaps.length}<br>`;
                    if (overlaps.length > 0) {
                        info += `<div class="warning">Overlaps detected:</div>`;
                        overlaps.forEach((overlap, i) => {
                            info += `${i + 1}: Point(${overlap.point.x.toFixed(1)}, ${overlap.point.y.toFixed(1)}) `;
                            info += `Distance: ${(overlap.fraction * 100).toFixed(1)}%<br>`;
                        });
                    }
                    this.updateInfo(info);
                }
            }

            // Demo 2: 360Â° Ray Casting Scanner
            class Demo2 extends DemoBase {
                constructor() {
                    super('demo2Canvas', 'demo2Info');
                }

                setupEvents() {
                    this.canvas.addEventListener('click', (e) => {
                        const rect = this.canvas.getBoundingClientRect();
                        this.scannerPos = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top,
                        };
                    });
                }

                init() {
                    // Initialize properties first
                    this.scannerPos = { x: 400, y: 200 };
                    this.scanRadius = 150;
                    this.numRays = 24;
                    this.animating = true;
                    this.animationOffset = 0;
                    this.resetDemo();
                }

                resetDemo() {
                    this.clearBodies();
                    // Add some obstacles
                    for (let i = 0; i < 6; i++) {
                        this.addRandomBody();
                    }
                }

                addRandomBody() {
                    const x = Math.random() * (this.canvas.width - 100) + 50;
                    const y = Math.random() * (this.canvas.height - 100) + 50;
                    const size = Math.random() * 40 + 20;

                    this.createCircle(x, y, size, 'static', {
                        color: '#ff8000',
                        type: 'obstacle',
                    });
                }

                toggleAnimation() {
                    this.animating = !this.animating;
                }

                render() {
                    super.render();

                    if (this.animating) {
                        this.animationOffset += 0.02;
                    }

                    // Draw scanner center
                    this.drawPoint(this.scannerPos.x, this.scannerPos.y, '#ff8000', 8);

                    let hitCount = 0;
                    const rayData = [];

                    // Cast rays in all directions
                    for (let i = 0; i < this.numRays; i++) {
                        const angle = (i / this.numRays) * Math.PI * 2 + this.animationOffset;
                        const endX = this.scannerPos.x + Math.cos(angle) * this.scanRadius;
                        const endY = this.scannerPos.y + Math.sin(angle) * this.scanRadius;

                        const closest = this.detector.getClosestLineOverlap(this.scannerPos, { x: endX, y: endY });

                        if (closest) {
                            hitCount++;
                            this.drawLine(this.scannerPos, closest.point, '#00ff00', 1);
                            this.drawPoint(closest.point.x, closest.point.y, '#ffff00', 3);
                            rayData.push({ hit: true, distance: closest.fraction * this.scanRadius, angle: angle });
                        } else {
                            this.drawLine(this.scannerPos, { x: endX, y: endY }, '#666666', 1);
                            rayData.push({ hit: false, distance: this.scanRadius, angle: angle });
                        }
                    }

                    // Update info
                    let info = `<div class="status">360Â° Ray Scanner</div>`;
                    info += `Scanner Position: (${this.scannerPos.x.toFixed(0)}, ${this.scannerPos.y.toFixed(0)})<br>`;
                    info += `Rays Cast: ${this.numRays}<br>`;
                    info += `Hits Detected: ${hitCount}<br>`;
                    info += `Hit Rate: ${((hitCount / this.numRays) * 100).toFixed(1)}%<br>`;
                    info += `Animation: ${this.animating ? 'ON' : 'OFF'}`;
                    this.updateInfo(info);
                }
            }

            // Demo 3: Line of Sight Testing
            class Demo3 extends DemoBase {
                constructor() {
                    super('demo3Canvas', 'demo3Info');
                }

                setupEvents() {
                    this.canvas.addEventListener('click', (e) => {
                        const rect = this.canvas.getBoundingClientRect();
                        const point = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top,
                        };

                        this.points.push(point);
                        if (this.points.length > 2) {
                            this.points = [point];
                        }
                    });
                }

                init() {
                    // Initialize properties first
                    this.points = [];
                    this.autoTestRunning = false;
                    this.resetDemo();
                }

                resetDemo() {
                    this.clearBodies();
                    this.points = [];
                    this.autoTestRunning = false;

                    // Add some obstacles
                    for (let i = 0; i < 5; i++) {
                        this.addObstacle();
                    }
                }

                addObstacle() {
                    const x = Math.random() * (this.canvas.width - 100) + 50;
                    const y = Math.random() * (this.canvas.height - 100) + 50;
                    const width = Math.random() * 60 + 40;
                    const height = Math.random() * 60 + 40;

                    this.createBody(x, y, width, height, 'static', {
                        color: '#8000ff',
                        type: 'obstacle',
                    });
                }

                clearObstacles() {
                    this.clearBodies();
                    this.points = [];
                }

                runPathTest() {
                    this.autoTestRunning = true;
                    this.points = [];

                    // Generate random test points
                    const testPaths = [
                        [
                            { x: 50, y: 50 },
                            { x: 750, y: 350 },
                        ],
                        [
                            { x: 100, y: 200 },
                            { x: 700, y: 200 },
                        ],
                        [
                            { x: 400, y: 50 },
                            { x: 400, y: 350 },
                        ],
                        [
                            { x: 750, y: 50 },
                            { x: 50, y: 350 },
                        ],
                    ];

                    let currentTest = 0;
                    const runTest = () => {
                        if (currentTest < testPaths.length) {
                            this.points = testPaths[currentTest];
                            currentTest++;
                            setTimeout(runTest, 1500);
                        } else {
                            this.autoTestRunning = false;
                            this.points = [];
                        }
                    };

                    runTest();
                }

                render() {
                    super.render();

                    // Draw test points
                    this.points.forEach((point, i) => {
                        this.drawPoint(point.x, point.y, '#8000ff', 8);

                        // Draw point label
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = '12px Arial';
                        this.ctx.fillText(i === 0 ? 'START' : 'END', point.x + 10, point.y - 10);
                    });

                    // Draw line of sight if we have two points
                    if (this.points.length === 2) {
                        const hasLOS = !this.detector.hasLineOverlap(this.points[0], this.points[1], (body) => {
                            return body.getUserData().type === 'obstacle';
                        });

                        this.drawLine(this.points[0], this.points[1], hasLOS ? '#00ff00' : '#ff0000', 4);

                        // Show blocking points if any
                        if (!hasLOS) {
                            const overlaps = this.detector.checkLineOverlap(this.points[0], this.points[1], (body) => {
                                return body.getUserData().type === 'obstacle';
                            });

                            overlaps.forEach((overlap) => {
                                this.drawPoint(overlap.point.x, overlap.point.y, '#ff0080', 6);
                            });
                        }
                    }

                    // Update info
                    let info = `<div class="status">Line of Sight Testing</div>`;
                    info += `Points Selected: ${this.points.length}/2<br>`;

                    if (this.points.length === 2) {
                        const hasLOS = !this.detector.hasLineOverlap(this.points[0], this.points[1], (body) => {
                            return body.getUserData().type === 'obstacle';
                        });

                        info += `<div class="${hasLOS ? 'status' : 'error'}">`;
                        info += `Line of Sight: ${hasLOS ? 'CLEAR' : 'BLOCKED'}</div>`;

                        const distance = Math.sqrt(
                            Math.pow(this.points[1].x - this.points[0].x, 2) + Math.pow(this.points[1].y - this.points[0].y, 2)
                        );
                        info += `Distance: ${distance.toFixed(1)} pixels<br>`;
                    }

                    if (this.autoTestRunning) {
                        info += `<div class="warning">Auto-testing paths...</div>`;
                    }

                    this.updateInfo(info);
                }
            }

            // Demo 4: Laser/Projectile Simulation
            class Demo4 extends DemoBase {
                constructor() {
                    super('demo4Canvas', 'demo4Info');
                }

                setupEvents() {
                    this.canvas.addEventListener('mousedown', (e) => {
                        const rect = this.canvas.getBoundingClientRect();
                        this.laserStart = {
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top,
                        };
                        this.isDragging = true;
                    });

                    this.canvas.addEventListener('mousemove', (e) => {
                        if (this.isDragging) {
                            const rect = this.canvas.getBoundingClientRect();
                            this.laserEnd = {
                                x: e.clientX - rect.left,
                                y: e.clientY - rect.top,
                            };
                        }
                    });

                    this.canvas.addEventListener('mouseup', () => {
                        this.isDragging = false;
                    });
                }

                init() {
                    // Initialize properties first
                    this.laserStart = { x: 100, y: 200 };
                    this.laserEnd = { x: 300, y: 200 };
                    this.isDragging = false;
                    this.lastFire = [];
                    this.resetDemo();
                }

                resetDemo() {
                    this.clearBodies();
                    this.lastFire = [];

                    // Add some targets
                    for (let i = 0; i < 8; i++) {
                        this.addTarget();
                    }
                }

                addTarget() {
                    const x = Math.random() * (this.canvas.width - 200) + 150;
                    const y = Math.random() * (this.canvas.height - 100) + 50;
                    const size = Math.random() * 20 + 15;

                    this.createCircle(x, y, size, 'dynamic', {
                        color: '#ff8000',
                        type: 'target',
                        health: 100,
                    });
                }

                clearTargets() {
                    this.clearBodies();
                    this.lastFire = [];
                }

                fireLaser() {
                    const targets = this.detector.checkLineOverlap(this.laserStart, this.laserEnd, (body) => {
                        return body.getUserData().type === 'target';
                    });

                    this.lastFire = targets;

                    // Damage targets
                    targets.forEach((target) => {
                        const userData = target.userData;
                        if (userData.health > 0) {
                            userData.health -= 25;
                            if (userData.health <= 0) {
                                userData.color = '#666666';
                            } else {
                                userData.color = `hsl(${userData.health * 1.2}, 70%, 60%)`;
                            }
                        }
                    });

                    // Clear after 1 second
                    setTimeout(() => {
                        this.lastFire = [];
                    }, 1000);
                }

                render() {
                    super.render();

                    // Draw laser beam
                    this.drawLine(this.laserStart, this.laserEnd, '#ff0000', 3);
                    this.drawPoint(this.laserStart.x, this.laserStart.y, '#ffffff', 6);

                    // Show potential targets
                    const targets = this.detector.checkLineOverlap(this.laserStart, this.laserEnd, (body) => {
                        return body.getUserData().type === 'target';
                    });

                    targets.forEach((target, i) => {
                        this.drawPoint(target.point.x, target.point.y, '#ffff00', 8);

                        // Draw target number
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = 'bold 14px Arial';
                        this.ctx.fillText(`${i + 1}`, target.point.x + 12, target.point.y - 12);
                    });

                    // Show last fire results
                    this.lastFire.forEach((target) => {
                        // Flash effect
                        this.ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                        this.ctx.beginPath();
                        this.ctx.arc(target.point.x, target.point.y, 20, 0, Math.PI * 2);
                        this.ctx.fill();
                    });

                    // Update info
                    let info = `<div class="status">Laser Targeting System</div>`;
                    info += `Laser Position: (${this.laserStart.x.toFixed(0)}, ${this.laserStart.y.toFixed(0)})<br>`;
                    info += `Aim Direction: (${this.laserEnd.x.toFixed(0)}, ${this.laserEnd.y.toFixed(0)})<br>`;
                    info += `Targets in Line: ${targets.length}<br>`;

                    if (targets.length > 0) {
                        info += `<div class="warning">Target Order:</div>`;
                        targets.forEach((target, i) => {
                            const health = target.userData.health || 0;
                            info += `${i + 1}: Distance ${(target.fraction * 100).toFixed(1)}% - Health: ${health}<br>`;
                        });
                    }

                    if (this.lastFire.length > 0) {
                        info += `<div class="error">FIRING! Hit ${this.lastFire.length} targets!</div>`;
                    }

                    this.updateInfo(info);
                }
            }

            // Initialize all demos
            window.demo1 = new Demo1();
            window.demo2 = new Demo2();
            window.demo3 = new Demo3();
            window.demo4 = new Demo4();
        </script>
    </body>
</html>
